/**
为了实现“既快又稳”的哈希表数据结构，哈希算法应具备以下特点。
‧ 确定性：对于相同的输入，哈希算法应始终产生相同的输出。这样才能确保哈希表是可靠的。
‧ 效率高：计算哈希值的过程应该足够快。计算开销越小，哈希表的实用性越高。
‧ 均匀分布：哈希算法应使得键值对均匀分布在哈希表中。分布越均匀，哈希冲突的概率就越低。
实际上，哈希算法除了可以用于实现哈希表，还广泛应用于其他领域中。
‧ 密码存储：为了保护用户密码的安全，系统通常不会直接存储用户的明文密码，而是存储密码的哈希
值。当用户输入密码时，系统会对输入的密码计算哈希值，然后与存储的哈希值进行比较。如果两者匹
配，那么密码就被视为正确。
‧ 数据完整性检查：数据发送方可以计算数据的哈希值并将其一同发送；接收方可以重新计算接收到的
数据的哈希值，并与接收到的哈希值进行比较。如果两者匹配，那么数据就被视为完整。
对于密码学的相关应用，为了防止从哈希值推导出原始密码等逆向工程，哈希算法需要具备更高等级的安全
特性。
‧ 单向性：无法通过哈希值反推出关于输入数据的任何信息。
‧ 抗碰撞性：应当极难找到两个不同的输入，使得它们的哈希值相同。
‧ 雪崩效应：输入的微小变化应当导致输出的显著且不可预测的变化。
请注意，“均匀分布”与“抗碰撞性”是两个独立的概念，满足均匀分布不一定满足抗碰撞性。例如，在随机
输入 key 下，哈希函数 key % 100 可以产生均匀分布的输出。然而该哈希算法过于简单，所有后两位相等的
key 的输出都相同，因此我们可以很容易地从哈希值反推出可用的 key ，从而破解密码。
 */

/* 加法哈希 */
addHash = (key) => {
  let hash = 0;
  const MODULUS = 1000000007;
  for (const c of key) {
    hash = (hash + c.charCodeAt(0)) % MODULUS;
  }
  return hash;
}

multiplyHash = (key) => {
  let hash = 1;
  const MODULUS = 1000000007;
  for (const c of key) {
    hash = (31 * hash + c.charCodeAt(0)) % MODULUS;
  }
  return hash;
}
